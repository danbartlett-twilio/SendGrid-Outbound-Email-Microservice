/**
 *  process-email-event
 * 
 * Lambda function triggered by createObject (JSON file) event in S3 SOURCE
 * bucket OR by a messaging sent to the SNS Topic. The JSON in the S3 Object
 * OR in the SNS message should contain well formatted JSON with the parameters
 * needed to make a successful call to the SendGrid API.
 * This function pulls the JSON from the S3 object or the SNS Message, 
 * adds additional configuration and then saves it to the request folder (prefix)
 * in the S3 bucket where the put event will trigger the send-email lambda.
 * 
 * This function is designed to handle email events with a SINGLE email. The 
 * SendGrid API can handle multiple emails in a single request. This function
 * could easily be altered to be able to handle multiple emails in a single request.
 * 
 */

// Functions used in multiple lambdas saved to a layer for DRY
import { getJsonObjectFromS3, saveToS3, sendSNSMessage }  from '/opt/shared-functions.mjs';

import { nanoid } from 'nanoid'; // Used to create unique IDs

async function configureMessageObject( key, messageObj ) {

    // Update the messageObj before initiating API Call to SendGrid
    /**
     * This function allows for additional configuration to
     * to the message object before it is sent to the send-email lambda
     * which executes the call to the SendGrid API.
     * 
     * ALL emails sent using this flow can have additional configurations
     * checked and set such as Global FROM, SUBJECT, Custom Arguments, Categories
     */


    /**
     * Key SendGrid documentation for configuring send email api call:
     * 
     * https://docs.sendgrid.com/api-reference/mail-send/mail-send
     * https://github.com/sendgrid/sendgrid-nodejs/blob/main/docs/use-cases/README.md#email-use-cases
     * 
     */

    /**
     * Add BCC
     * 
     * If you require sending a copy of every (or certain) emails to
     * achieval purposes, add it here like this:
     * 
     * messageObj.bcc = "some-email-address@some-domain.com";
     * 
     * ...or conditionally add it if certain criteria are met.
     * 
     */    


    // Test if the obj has a custom arguments property, if not, add it
    if (!messageObj.hasOwnProperty('customArgs')) {
        messageObj.customArgs = {};
    }    

    // Unique ID generated by customer and included in call to SendGrid.
    // Enables additional tracking from SendGrid events back to original request.
    messageObj.customArgs.requestId = key;

    /**
     * This solution template assumes a single API Key. Many organizations
     * have multiple API Keys so this is where you would enable business logic
     * to set the correct API Key to use. It can be helpful to include the
     * API KEY ID (not the actually API Key for security reasons!) as 
     * a custom argument.
     * 
     * The API KEY ID can be passed in, or it can be set by business logic.
     * 
     * The API KEY ID set here could be used to GET the correct API KEY 
     * to use in the send-email lambda.
     * 
     */    
    messageObj.customArgs.apiKeyId = process.env.SENDGRID_API_KEY_ID;
    
    // Best practice is to include these common email attributes
    // as custom arguments for tracking / visibility / reporting
    if (messageObj.hasOwnProperty('subject'))
        messageObj.customArgs.subject = messageObj.subject;

    if (messageObj.hasOwnProperty('from'))        
        messageObj.customArgs.globalFrom = messageObj.from; // global prefix in case overwritten by personalization

    if (messageObj.hasOwnProperty('replyTo'))        
        messageObj.customArgs.globalReplyTo = messageObj.replyTo; // global prefix in case overwritten by personalization

    // If a templateId is being used, it makes sense to include it
    // for additional tracking and reporting
    if (messageObj.hasOwnProperty('templateId'))                
        messageObj.customArgs.templateId = messageObj.templateId;

    if (messageObj.hasOwnProperty('batchId'))                        
        messageObj.customArgs.batchId = messageObj.batchId;

    /**
     * CONSIDER CHECKING FROM, SUBJECT, TO
     * 
     * You could check the FROM address in the message object to
     * be sure it is correct and fits your business logic.
     * 
     * Check the SUBJECT for prohibited words and policies.
     * 
     * Optionally check the TO email address for presence on
     * any opt-out or block lists or black out times, or other
     * business logic.
     * 
     */

    /**
     * CONSIDER ADDITIONAL CUSTOM ARGUMENTS!
     * 
     * In addition to the arguments above added to custom arguments consider adding 
     * other attributes that are relevant to your business. 
     * 
     * For example, you could check for customer ID, or order ID. If they are not
     * present, you could conditionally look them up and add them here. 
     * 
     *  => messageObj.customArgs.customerID = 5598038943;
     *  => messageObj.customArgs.orderId = 'or331Kdda332';
     * 
     * Message type, event origination source/application, cost center, campaign
     * account or support representative, or anything else you want to track. 
     * 
    */ 

    /**
     * CONSIDER ADDING CATEGORIES!
     * 
     * In addition to the arguments above added to customer arguments consider adding 
     * categories based on message attributes. Categories can be passed in the object,
     * but could also be conditionally added (simple example below). Categories show
     * up automatically in the SendGrid Dashboard (STATS) so it is best practice to
     * add them to all of your outbound emails. 
     * 
     *      if (!messageObj.hasOwnProperty('categories')) {
     *          let categories = getApplicableCategries(someProperties);
     *          messageObj.categories = categories;
     *      }
     * 
     *      or 
     * 
     *      if ( <CERTAIN-BUSINESS-CRITERIA-MET> ) {
     *          let categories = getApplicableCategries(someProperties);
     *          messageObj.categories = categories;
     *      }
     * 
    */ 

    console.info("messageObj => ",messageObj);

    return messageObj;

}

export const lambdaHandler = async (event, context) => {
        
    //console.log("event is => ", event);            

    /**
     * Events are passed in either from an S3 Put Event (object
     * loaded into the /uploads folder of the S3 bucket) OR from
     * a message sent to the SNS topic. Depending on the source,
     * assign originalMessageObj accordingly.
     */
    let originalMessageObj;    
    if (event.Records[0].EventSource !== undefined && event.Records[0].EventSource === 'aws:sns') {
        // Event is from SNS
        originalMessageObj = JSON.parse(event.Records[0].Sns.Message);
    } else {
        // Event is from S3 PUT event
        originalMessageObj = await getJsonObjectFromS3(event.Records[0]);
    }

    if (originalMessageObj) {

        // Generate a unique ID for EACH request!
        // This ID can be tracked via email webhook events
        let requestId = 'SGR' + nanoid();
        console.log("unque id from nanoid is => ", requestId);

        // Configure JSON Object before calling SendGrid API
        let messageObj = await configureMessageObject(requestId, originalMessageObj);

        // Save formatted request object (messageObj) to the S3 bucket
        await saveToS3(`requests/${requestId}.json`, process.env.BucketName, messageObj);
    
    } else {

        // Problem getting JSON object from triggering event
        // Send message to SNS  

        await sendSNSMessage(process.env.SNStopic,{sourceLambda:"SendGridProcessEmailEventFunction",message:"Mail object not correctly parsed ",event:event});        

    }

};